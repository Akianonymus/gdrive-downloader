#!/usr/bin/env bash
SELF_SOURCE="true"
_assert_regex(){
declare pattern="${1:?Error: Missing pattern}" string="${2:?Missing string}"
if [[ $string =~ $pattern ]];then
return 0
else
return 1
fi
}
_count(){
mapfile -tn 0 lines
printf '%s\n' "${#lines[@]}"
}
_epoch(){
printf '%(%s)T\n' "-1"
}
_flag_help(){
case "$1" in
set)for f in $2
do
_set_value d "help_${f//-/}" "$3"
done
;;
get)_set_value i "$2" "help_${3//-/}"
;;
*)return 1
esac
}
_required_column_size(){
shopt -s checkwinsize&&(:&&:)
if [[ $COLUMNS -gt 45 ]];then
trap 'shopt -s checkwinsize; (:;:)' SIGWINCH
return 0
else
return 1
fi
}
_set_value(){
case "${1:?}" in
d|direct)export "${2:?}=$3";;
i|indirect)export "${2:?}=${!3}";;
*)return 1
esac
}
export -f _count \
_set_value
_account_name_valid(){
name_account_name_valid="${1:?}" account_name_regex_account_name_valid='^([A-Za-z0-9_])+$'
_assert_regex "$account_name_regex_account_name_valid ""$name_account_name_valid"||return 1
return 0
}
_account_exists(){
name_account_exists="${1:-}" client_id_account_exists="" client_secret_account_exists="" refresh_token_account_exists=""
_account_name_valid "$name_account_exists"||return 1
_set_value indirect client_id_account_exists "ACCOUNT_${name_account_exists}_CLIENT_ID"
_set_value indirect client_secret_account_exists "ACCOUNT_${name_account_exists}_CLIENT_SECRET"
_set_value indirect refresh_token_account_exists "ACCOUNT_${name_account_exists}_REFRESH_TOKEN"
[ -z "${client_id_account_exists:+${client_secret_account_exists:+$refresh_token_account_exists}}" ]&&return 1
return 0
}
_all_accounts(){
export CONFIG QUIET
{ _reload_config&&_handle_old_config;}||return 1
COUNT=0
while read -r account <&4&&[ -n "$account" ];do
_account_exists "$account"&&{ [ "$COUNT" = 0 ]&&"${QUIET:-_print_center}" "normal" " All available accounts. " "="||:;}&&printf "%b" "$((COUNT+=1)). $account \n"&&_set_value direct "ACC_${COUNT}_ACC" "$account"
done 4<<EOF
$(grep -oE '^ACCOUNT_.*_CLIENT_ID' "$CONFIG"|sed -e "s/ACCOUNT_//g" -e "s/_CLIENT_ID//g")
EOF
{ [ "$COUNT" -le 0 ]&&"${QUIET:-_print_center}" "normal" " No accounts configured yet. " "=" 1>&2;}||printf '\n'
return 0
}
_set_new_account_name(){
export QUIET NEW_ACCOUNT_NAME
_reload_config||return 1
new_account_name_set_new_account_name="${1:-}"&&unset name_valid_set_new_account_name
[ -z "$new_account_name_set_new_account_name" ]&&{
_all_accounts 2>|/dev/null
"${QUIET:-_print_center}" "normal" " New account name: " "="
"${QUIET:-_print_center}" "normal" "Info: Account names can only contain alphabets / numbers / dashes." " "&&printf '\n'
}
until [ -n "$name_valid_set_new_account_name" ];do
if [ -n "$new_account_name_set_new_account_name" ];then
if _account_name_valid "$new_account_name_set_new_account_name";then
if _account_exists "$new_account_name_set_new_account_name";then
"${QUIET:-_print_center}" "normal" " Warning: Given account ( $new_account_name_set_new_account_name ) already exists, input different name. " "-" 1>&2
unset new_account_name_set_new_account_name&&continue
else
export new_account_name_set_new_account_name="$new_account_name_set_new_account_name" ACCOUNT_NAME="$new_account_name_set_new_account_name"&&name_valid_set_new_account_name="true"&&continue
fi
else
"${QUIET:-_print_center}" "normal" " Warning: Given account name ( $new_account_name_set_new_account_name ) invalid, input different name. " "-"
unset new_account_name_set_new_account_name&&continue
fi
else
[ -t 1 ]||{ "${QUIET:-_print_center}" "normal" " Error: Not running in an interactive terminal, cannot ask for new account name. " 1>&2&&return 1;}
printf -- "-> \033[?7l"
read -r new_account_name_set_new_account_name
printf '\033[?7h'
fi
_clear_line 1
done
"${QUIET:-_print_center}" "normal" " Given account name: $NEW_ACCOUNT_NAME " "="
export ACCOUNT_NAME="$NEW_ACCOUNT_NAME"
return 0
}
_delete_account(){
export CONFIG QUIET
{ _reload_config&&_handle_old_config;}||return 1
account_delete_account="${1:?Error: give account name}"&&unset regex_delete_account config_without_values_delete_account
if _account_exists "$account_delete_account";then
regex_delete_account="^ACCOUNT_${account_delete_account}_(CLIENT_ID=|CLIENT_SECRET=|REFRESH_TOKEN=|ROOT_FOLDER=|ROOT_FOLDER_NAME=|ACCESS_TOKEN=|ACCESS_TOKEN_EXPIRY=)|DEFAULT_ACCOUNT=\"$account_delete_account\""
config_without_values_delete_account="$(grep -vE "$regex_delete_account" "$CONFIG")"
chmod u+w "$CONFIG"||return 1
printf "%s\n" "$config_without_values_delete_account" >|"$CONFIG"||return 1
chmod "a-w-r-x,u+r" "$CONFIG"||return 1
"${QUIET:-_print_center}" "normal" " Successfully deleted account ( $account_delete_account ) from config. " "-"
else
"${QUIET:-_print_center}" "normal" " Error: Cannot delete account ( $account_delete_account ) from config. No such account exists " "-" 1>&2
fi
return 0
}
_handle_old_config(){
export CLIENT_ID CLIENT_SECRET REFRESH_TOKEN ROOT_FOLDER ROOT_FOLDER_NAME
[ -n "${CLIENT_ID:+${CLIENT_SECRET:+$REFRESH_TOKEN}}" ]&&{
account_name_handle_old_config="default" regex_check_handle_old_config config_without_values_handle_old_config count_handle_old_config
until ! _account_exists "$account_name_handle_old_config";do
account_name_handle_old_config="$account_name_handle_old_config$((count_handle_old_config+=1))"
done
regex_check_handle_old_config="^(CLIENT_ID=|CLIENT_SECRET=|REFRESH_TOKEN=|ROOT_FOLDER=|ROOT_FOLDER_NAME=|ACCESS_TOKEN=|ACCESS_TOKEN_EXPIRY=)"
config_without_values_handle_old_config="$(grep -vE "$regex_check_handle_old_config" "$CONFIG")"
chmod u+w "$CONFIG"||return 1
printf "%s\n%s\n%s\n%s\n%s\n%s\n" \
"ACCOUNT_${account_name_handle_old_config}_CLIENT_ID=\"$CLIENT_ID\"" \
"ACCOUNT_${account_name_handle_old_config}_CLIENT_SECRET=\"$CLIENT_SECRET\"" \
"ACCOUNT_${account_name_handle_old_config}_REFRESH_TOKEN=\"$REFRESH_TOKEN\"" \
"ACCOUNT_${account_name_handle_old_config}_ROOT_FOLDER=\"$ROOT_FOLDER\"" \
"ACCOUNT_${account_name_handle_old_config}_ROOT_FOLDER_NAME=\"$ROOT_FOLDER_NAME\"" \
"$config_without_values_handle_old_config" >|"$CONFIG"||return 1
chmod "a-w-r-x,u+r" "$CONFIG"||return 1
_reload_config||return 1
}
return 0
}
_check_credentials(){
export CONFIG CONFIG_INFO DEFAULT_ACCOUNT NEW_ACCOUNT_NAME CUSTOM_ACCOUNT_NAME QUIET DEFAULT_ACCOUNT COUNT
{ _reload_config&&_handle_old_config;}||return 1
ACCOUNT_NAME="$DEFAULT_ACCOUNT"
if [ -n "$NEW_ACCOUNT_NAME" ];then
_set_new_account_name "$NEW_ACCOUNT_NAME"||return 1
_check_account_credentials "$ACCOUNT_NAME"||return 1
else
if [ -n "$CUSTOM_ACCOUNT_NAME" ];then
if _account_exists "$CUSTOM_ACCOUNT_NAME";then
ACCOUNT_NAME="$CUSTOM_ACCOUNT_NAME"
else
"${QUIET:-_print_center}" "normal" " Error: No such account ( $CUSTOM_ACCOUNT_NAME ) exists. " "-"&&return 1
fi
elif [ -n "$DEFAULT_ACCOUNT" ];then
_account_exists "$DEFAULT_ACCOUNT"||{
_update_config DEFAULT_ACCOUNT "" "$CONFIG"&&unset DEFAULT_ACCOUNT ACCOUNT_NAME&&UPDATE_DEFAULT_ACCOUNT="_update_config"
}
else
UPDATE_DEFAULT_ACCOUNT="_update_config"
fi
if [ -z "$ACCOUNT_NAME" ];then
if _all_accounts 2>|/dev/null&&[ "$COUNT" -gt 0 ];then
if [ "$COUNT" -eq 1 ];then
_set_value indirect ACCOUNT_NAME "ACC_1_ACC"
else
"${QUIET:-_print_center}" "normal" " Above accounts are configured, but default one not set. " "="
if [ -t 1 ];then
"${QUIET:-_print_center}" "normal" " Choose default account: " "-"
until [ -n "$ACCOUNT_NAME" ];do
printf -- "-> \033[?7l"
read -r account_name_check_credentials
printf '\033[?7h'
if [ "$account_name_check_credentials" -gt 0 ]&&[ "$account_name_check_credentials" -le "$COUNT" ];then
_set_value indirect ACCOUNT_NAME "ACC_${COUNT}_ACC"
else
_clear_line 1
fi
done
else
printf "%s\n" "Warning: Script is not running in a terminal, choosing first account as default."
_set_value indirect ACCOUNT_NAME "ACC_1_ACC"
fi
fi
else
_set_new_account_name ""||return 1
_check_account_credentials "$ACCOUNT_NAME"||return 1
fi
fi
_check_account_credentials "$ACCOUNT_NAME"||return 1
fi
"${UPDATE_DEFAULT_ACCOUNT:-:}" DEFAULT_ACCOUNT "$ACCOUNT_NAME" "$CONFIG"
"${UPDATE_DEFAULT_CONFIG:-:}" CONFIG "$CONFIG" "$CONFIG_INFO"
[ -n "$CONTINUE_WITH_NO_INPUT" ]||_token_bg_service
return 0
}
_check_account_credentials(){
account_name_check_account_credentials="${1:?Give account name}"
{
_check_client ID "$account_name_check_account_credentials"&&_check_client SECRET "$account_name_check_account_credentials"&&_check_refresh_token "$account_name_check_account_credentials"&&_check_access_token "$account_name_check_account_credentials" check
}||return 1
return 0
}
_check_client(){
export CONFIG QUIET
type_check_client="CLIENT_${1:?Error: ID or SECRET}" account_name_check_client="${2:-}"
type_value_check_client="" type_regex_check_client=""&&unset type_name_check_client valid_check_client client_check_client message_check_client
export client_id_regex='[0-9]+-[0-9A-Za-z_]{32}\.apps\.googleusercontent\.com' client_secret_regex='[0-9A-Za-z_-]+'
type_name_check_client="${account_name_check_client:+ACCOUNT_${account_name_check_client}_}$type_check_client"
_set_value indirect type_value_check_client "$type_name_check_client"
_set_value indirect type_regex_check_client "${type_check_client}_regex"
until [ -n "$type_value_check_client" ]&&[ -n "$valid_check_client" ];do
[ -n "$type_value_check_client" ]&&{
if _assert_regex "$type_regex_check_client" "$type_value_check_client";then
[ -n "$client_check_client" ]&&{ _update_config "$type_name_check_client" "$type_value_check_client" "$CONFIG"||return 1;}
valid_check_client="true"&&continue
else
{ [ -n "$client_check_client" ]&&message_check_client="- Try again";}||message_check_client="in config ( $CONFIG )"
"${QUIET:-_print_center}" "normal" " Invalid Client $1 $message_check_client " "-"&&unset "$type_name_check_client" client
fi
}
[ -z "$client_check_client" ]&&printf "\n"&&"${QUIET:-_print_center}" "normal" " Enter Client $1 " "-"
[ -n "$client_check_client" ]&&_clear_line 1
printf -- "-> "
read -r "${type_name_check_client?}"&&client_check_client=1
_set_value indirect type_value_check_client "$type_name_check_client"
done
_set_value direct "$type_name_check_client" "$type_value_check_client"
_set_value direct "$type_check_client" "$type_value_check_client"
return 0
}
_check_refresh_token(){
export CLIENT_ID CLIENT_SECRET QUIET CONFIG CURL_PROGRESS SCOPE REDIRECT_URI TOKEN_URL
[ -z "${CLIENT_ID:+$CLIENT_SECRET}" ]&&return 1
account_name_check_refresh_token="${1:-}"
refresh_token_regex='[0-9]//[0-9A-Za-z_-]+' authorization_code_regex='[0-9]/[0-9A-Za-z_-]+'
refresh_token_name_check_refresh_token="${account_name_check_refresh_token:+ACCOUNT_${account_name_check_refresh_token}_}REFRESH_TOKEN"
_set_value indirect refresh_token_value_check_refresh_token "$refresh_token_name_check_refresh_token"
[ -n "$refresh_token_value_check_refresh_token" ]&&{
! _assert_regex "$refresh_token_regex" "$refresh_token_value_check_refresh_token"&&"${QUIET:-_print_center}" "normal" " Error: Invalid Refresh token in config file, follow below steps.. " "-"&&unset refresh_token_value_check_refresh_token
}
[ -z "$refresh_token_value_check_refresh_token" ]&&{
printf "\n"&&"${QUIET:-_print_center}" "normal" "If you have a refresh token generated, then type the token, else leave blank and press return key.." " "
printf "\n"&&"${QUIET:-_print_center}" "normal" " Refresh Token " "-"&&printf -- "-> "
read -r refresh_token_value_check_refresh_token
if [ -n "$refresh_token_value_check_refresh_token" ];then
"${QUIET:-_print_center}" "normal" " Checking refresh token.. " "-"
if _assert_regex "$refresh_token_regex" "$refresh_token_value_check_refresh_token";then
_set_value direct REFRESH_TOKEN "$refresh_token_value_check_refresh_token"
{ _check_access_token "$account_name_check_refresh_token" skip_check&&_update_config "$refresh_token_name_check_refresh_token" "$refresh_token_value_check_refresh_token" "$CONFIG"&&_clear_line 1;}||check_error_check_refresh_token=true
else
check_error_check_refresh_token=true
fi
[ -n "$check_error_check_refresh_token" ]&&"${QUIET:-_print_center}" "normal" " Error: Invalid Refresh token given, follow below steps to generate.. " "-"&&unset refresh_token_value_check_refresh_token
else
"${QUIET:-_print_center}" "normal" " No Refresh token given, follow below steps to generate.. " "-"&&unset refresh_token_value_check_refresh_token
fi
[ -z "$refresh_token_value_check_refresh_token" ]&&{
printf "\n"&&"${QUIET:-_print_center}" "normal" "Visit the below URL, tap on allow and then enter the code obtained" " "
URL="https://accounts.google.com/o/oauth2/auth?client_id=$CLIENT_ID&redirect_uri=$REDIRECT_URI&scope=$SCOPE&response_type=code&prompt=consent"
printf "\n%s\n" "$URL"
unset AUTHORIZATION_CODE authorization_code AUTHORIZATION_CODE_VALID response
until [ -n "$AUTHORIZATION_CODE" ]&&[ -n "$AUTHORIZATION_CODE_VALID" ];do
[ -n "$AUTHORIZATION_CODE" ]&&{
if _assert_regex "$authorization_code_regex" "$AUTHORIZATION_CODE";then
AUTHORIZATION_CODE_VALID="true"&&continue
else
"${QUIET:-_print_center}" "normal" " Invalid CODE given, try again.. " "-"&&unset AUTHORIZATION_CODE authorization_code
fi
}
{ [ -z "$authorization_code" ]&&printf "\n"&&"${QUIET:-_print_center}" "normal" " Enter the authorization code " "-";}||_clear_line 1
printf -- "-> \033[?7l"
read -r AUTHORIZATION_CODE&&authorization_code=1
printf '\033[?7h'
done
response_check_refresh_token="$(_curl --compressed "$CURL_PROGRESS" -X POST \
--data "code=$AUTHORIZATION_CODE&client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET&redirect_uri=$REDIRECT_URI&grant_type=authorization_code" "$TOKEN_URL")"||:
_clear_line 1 1>&2
refresh_token_value_check_refresh_token="$(printf "%s\n" "$response_check_refresh_token"|_json_value refresh_token 1 1)"||{ printf "%s\n" "Error: Cannot fetch refresh token, make sure the authorization code was correct."&&return 1;}
_set_value direct REFRESH_TOKEN "$refresh_token_value_check_refresh_token"
{ _check_access_token "$account_name_check_refresh_token" skip_check "$response_check_refresh_token"&&_update_config "$refresh_token_name_check_refresh_token" "$refresh_token_value_check_refresh_token" "$CONFIG";}||return 1
}
printf "\n"
}
_set_value direct "$refresh_token_name_check_refresh_token" "$refresh_token_value_check_refresh_token"
_set_value direct REFRESH_TOKEN "$refresh_token_value_check_refresh_token"
return 0
}
_check_access_token(){
export CLIENT_ID CLIENT_SECRET REFRESH_TOKEN CONFIG QUIET
[ -z "${CLIENT_ID:+${CLIENT_SECRET:+$REFRESH_TOKEN}}" ]&&return 1
account_name_check_access_token="${1:-}" no_check_check_access_token="${2:-false}" response_json_check_access_token="${3:-}"
unset token_name_check_access_token token_expiry_name_check_access_token token_value_check_access_token token_expiry_value_check_access_token response_check_access_token
access_token_regex='ya29\.[0-9A-Za-z_-]+'
token_name_check_access_token="${account_name_check_access_token:+ACCOUNT_${account_name_check_access_token}_}ACCESS_TOKEN"
token_expiry_name_check_access_token="${token_name_check_access_token}_EXPIRY"
_set_value indirect token_value_check_access_token "$token_name_check_access_token"
_set_value indirect token_expiry_value_check_access_token "$token_expiry_name_check_access_token"
[ "$no_check_check_access_token" = skip_check ]||[ -z "$token_value_check_access_token" ]||[ "${token_expiry_value_check_access_token:-0}" -lt "$(_epoch)" ]||! _assert_regex "$access_token_regex" "$token_value_check_access_token"&&{
response_check_access_token="${response_json_check_access_token:-$(curl --compressed -s -X POST --data \
"client_id=$CLIENT_ID&client_secret=$CLIENT_SECRET&refresh_token=$REFRESH_TOKEN&grant_type=refresh_token" "$TOKEN_URL")}"||:
if token_value_check_access_token="$(printf "%s\n" "$response_check_access_token"|_json_value access_token 1 1)";then
token_expiry_value_check_access_token="$(($(_epoch)+$(printf "%s\n" "$response_check_access_token"|_json_value expires_in 1 1)-1))"
_update_config "$token_name_check_access_token" "$token_value_check_access_token" "$CONFIG"||return 1
_update_config "$token_expiry_name_check_access_token" "$token_expiry_value_check_access_token" "$CONFIG"||return 1
else
"${QUIET:-_print_center}" "justify" "Error: Something went wrong" ", printing error." "=" 1>&2
printf "%s\n" "$response_check_access_token" 1>&2
return 1
fi
}
_set_value direct ACCESS_TOKEN "$token_value_check_access_token"
_set_value direct ACCESS_TOKEN_EXPIRY "$token_expiry_value_check_access_token"
_set_value direct INITIAL_ACCESS_TOKEN "$ACCESS_TOKEN"
return 0
}
_reload_config(){
export CONFIG
{ [ -r "$CONFIG" ]&&. "$CONFIG";}||{ printf "" >>"$CONFIG"||return 1;}
return 0
}
_token_bg_service(){
export MAIN_PID ACCESS_TOKEN ACCESS_TOKEN_EXPIRY TMPFILE
[ -z "$MAIN_PID" ]&&return 0
printf "%b\n" "ACCESS_TOKEN=\"$ACCESS_TOKEN\"\nACCESS_TOKEN_EXPIRY=\"$ACCESS_TOKEN_EXPIRY\"" >|"${TMPFILE}_ACCESS_TOKEN"
{
until ! kill -0 "$MAIN_PID" 2>|/dev/null 1>&2;do
. "${TMPFILE}_ACCESS_TOKEN"
CURRENT_TIME="$(_epoch)"
REMAINING_TOKEN_TIME="$((ACCESS_TOKEN_EXPIRY-CURRENT_TIME))"
if [ "$REMAINING_TOKEN_TIME" -le 300 ];then
CONFIG="${TMPFILE}_ACCESS_TOKEN" _timeout 30 _check_access_token "" skip_check||:
else
TOKEN_PROCESS_TIME_TO_SLEEP="$(if [ "$REMAINING_TOKEN_TIME" -le 301 ];then
printf "0\n"
else
printf "%s\n" "$((REMAINING_TOKEN_TIME-300))"
fi)"
sleep "$TOKEN_PROCESS_TIME_TO_SLEEP"
fi
sleep 1
done
}&
export ACCESS_TOKEN_SERVICE_PID="$!"
return 0
}
{
[ "${_SHELL:-}" = "bash" ]&&tmp="-f"&&export "${tmp?}" _check_access_token \
_token_bg_service
} 2>|/dev/null 1>&2||:
_actual_size_in_bytes(){
file_actual_size_in_bytes="${1:?Error: give filename}"
{ _tmp="$(BLOCK_SIZE=512 BLOCKSIZE=512 du "$file_actual_size_in_bytes")"&&_tmp="${_tmp%%"$(printf '\t')"*}"&&printf "%s\n" "$((_tmp*512))";}||return 1
}
_bytes_to_human(){
b_bytes_to_human="$(printf "%.0f\n" "${1:-0}")" s_bytes_to_human=0
d_bytes_to_human='' type_bytes_to_human=''
while [ "$b_bytes_to_human" -gt 1024 ];do
d_bytes_to_human="$(printf ".%02d" $((b_bytes_to_human%1024*100/1024)))"
b_bytes_to_human=$((b_bytes_to_human/1024))&&s_bytes_to_human=$((s_bytes_to_human+=1))
done
j=0&&for i in B KB MB GB TB PB EB YB ZB;do
j="$((j+=1))"&&[ "$((j-1))" = "$s_bytes_to_human" ]&&type_bytes_to_human="$i"&&break
continue
done
printf "%s\n" "$b_bytes_to_human$d_bytes_to_human $type_bytes_to_human"
}
_check_debug(){
export DEBUG QUIET
if [ -n "$DEBUG" ];then
set -x&&PS4='-> '
_print_center(){ { [ $# = 3 ]&&printf "%s\n" "$2";}||{ printf "%s%s\n" "$2" "$3";};}
_clear_line(){ :;}&&_move_cursor(){ :;}&&_newline(){ :;}
else
if [ -z "$QUIET" ];then
if _support_ansi_escapes;then
if ! _required_column_size;then
_print_center(){ { [ $# = 3 ]&&printf "%s\n" "[ $2 ]";}||{ printf "%s\n" "[ $2$3 ]";};}
fi
export EXTRA_LOG="_print_center" CURL_PROGRESS="-#" SUPPORT_ANSI_ESCAPES="true"
else
_print_center(){ { [ $# = 3 ]&&printf "%s\n" "[ $2 ]";}||{ printf "%s\n" "[ $2$3 ]";};}
_clear_line(){ :;}&&_move_cursor(){ :;}
fi
_newline(){ printf "%b" "$1";}
else
_print_center(){ :;}&&_clear_line(){ :;}&&_move_cursor(){ :;}&&_newline(){ :;}
fi
set +x
fi
{
[ "${_SHELL:-}" = "bash" ]&&tmp="-f"&&export "${tmp?}" _newline \
_print_center \
_clear_line
} 2>|/dev/null 1>&2||:
}
_check_internet(){
"${EXTRA_LOG:-}" "justify" "Checking Internet Connection.." "-"
if ! _timeout 10 _curl -Is google.com --compressed;then
_clear_line 1
"${QUIET:-_print_center}" "justify" "Error: Internet connection" " not available." "="
return 1
fi
_clear_line 1
}
_clear_line(){
printf "\033[%sA\033[2K" "$1"
}
_curl(){
curl ${CURL_FLAGS:-} "$@"||return 1
}
_display_time(){
t_display_time="$1" day_display_time="$((t_display_time/60/60/24))"
hr_display_time="$((t_display_time/60/60%24))" min_display_time="$((t_display_time/60%60))" sec_display_time="$((t_display_time%60))"
[ "$day_display_time" -gt 0 ]&&printf '%d days ' "$day_display_time"
[ "$hr_display_time" -gt 0 ]&&printf '%d hrs ' "$hr_display_time"
[ "$min_display_time" -gt 0 ]&&printf '%d minute(s) ' "$min_display_time"
[ "$day_display_time" -gt 0 ]||[ "$hr_display_time" -gt 0 ]||[ "$min_display_time" -gt 0 ]&&printf 'and '
printf '%d seconds\n' "$sec_display_time"
}
_get_latest_sha(){
export TYPE TYPE_VALUE REPO
unset latest_sha_get_latest_sha raw_get_latest_sha
case "${1:-$TYPE}" in
branch)\
latest_sha_get_latest_sha="$(\
raw_get_latest_sha="$(curl --compressed -s https://github.com/"${3:-$REPO}"/commits/"${2:-$TYPE_VALUE}".atom -r 0-2000)"
_tmp="$(printf "%s\n" "$raw_get_latest_sha"|grep -o 'Commit\/.*<' -m1||:)"&&_tmp="${_tmp##*\/}"&&printf "%s\n" "${_tmp%%<*}")"
;;
release)\
latest_sha_get_latest_sha="$(\
raw_get_latest_sha="$(curl -L --compressed -s https://github.com/"${3:-$REPO}"/releases/"${2:-$TYPE_VALUE}")"
_tmp="$(printf "%s\n" "$raw_get_latest_sha"|grep '="/'"${3:-$REPO}""/commit" -m1||:)"&&_tmp="${_tmp##*commit\/}"&&printf "%s\n" "${_tmp%%\"*}")"
;;
*):
esac
printf "%b" "${latest_sha_get_latest_sha:+$latest_sha_get_latest_sha\n}"
}
_json_value(){
{ [ "$2" -gt 0 ] 2>|/dev/null&&no_of_lines_json_value="$2";}||:
{ [ "$3" -gt 0 ] 2>|/dev/null&&num_json_value="$3";}||{ ! [ "$3" = all ]&&num_json_value=1;}
_tmp="$(grep -o "\"$1\"\:.*" ${no_of_lines_json_value:+-m} $no_of_lines_json_value)"||return 1
printf "%s\n" "$_tmp"|sed -e 's/.*"'"$1""\"://" -e 's/[",]*$//' -e 's/["]*$//' -e 's/[,]*$//' -e "s/^ //" -e 's/^"//' -n -e "$num_json_value"p||:
return 0
}
_move_cursor(){
printf "\033[%sA" "${1:?Error: Num of line}"
}
_print_center(){
[ $# -lt 3 ]&&printf "Missing arguments\n"&&return 1
term_cols_print_center="${COLUMNS:-}"
type_print_center="$1" filler_print_center=""
case "$type_print_center" in
normal)out_print_center="$2"&&symbol_print_center="$3";;
justify)if
[ $# = 3 ]
then
input1_print_center="$2" symbol_print_center="$3" to_print_print_center="" out_print_center=""
to_print_print_center="$((term_cols_print_center-5))"
{ [ "${#input1_print_center}" -gt "$to_print_print_center" ]&&out_print_center="[ $(printf "%.${to_print_print_center}s\n" "$input1_print_center")..]";}||{ out_print_center="[ $input1_print_center ]";}
else
input1_print_center="$2" input2_print_center="$3" symbol_print_center="$4" to_print_print_center="" temp_print_center="" out_print_center=""
to_print_print_center="$((term_cols_print_center*47/100))"
{ [ "${#input1_print_center}" -gt "$to_print_print_center" ]&&temp_print_center=" $(printf "%.${to_print_print_center}s\n" "$input1_print_center")..";}||{ temp_print_center=" $input1_print_center";}
to_print_print_center="$((term_cols_print_center*46/100))"
{ [ "${#input2_print_center}" -gt "$to_print_print_center" ]&&temp_print_center="$temp_print_center$(printf "%.${to_print_print_center}s\n" "$input2_print_center").. ";}||{ temp_print_center="$temp_print_center$input2_print_center ";}
out_print_center="[$temp_print_center]"
fi
;;
*)return 1
esac
str_len_print_center="${#out_print_center}"
[ "$str_len_print_center" -ge "$((term_cols_print_center-1))" ]&&{
printf "%s\n" "$out_print_center"&&return 0
}
filler_print_center_len="$(((term_cols_print_center-str_len_print_center)/2))"
i_print_center=1&&while [ "$i_print_center" -le "$filler_print_center_len" ];do
filler_print_center="$filler_print_center$symbol_print_center"&&i_print_center="$((i_print_center+1))"
done
printf "%s%s%s" "$filler_print_center" "$out_print_center" "$filler_print_center"
[ "$(((term_cols_print_center-str_len_print_center)%2))" -ne 0 ]&&printf "%s" "$symbol_print_center"
printf "\n"
return 0
}
_print_center_quiet(){
{ [ $# = 3 ]&&printf "%s\n" "$2";}||{ printf "%s%s\n" "$2" "$3";}
}
_support_ansi_escapes(){
unset ansi_escapes
case "${TERM:-}" in
xterm*|rxvt*|urxvt*|linux*|vt*|screen*)ansi_escapes="true";;
*):
esac
{ [ -t 2 ]&&[ -n "$ansi_escapes" ]&&return 0;}||return 1
}
_timeout(){
timeout_timeout="${1:?Error: Specify Timeout}"&&shift
{
"$@"&
child="$!"
trap -- "" TERM
{
sleep "$timeout_timeout"
kill -9 "$child"
}&
wait "$child"
} 2>|/dev/null 1>&2
}
_update_config(){
[ $# -lt 3 ]&&printf "Missing arguments\n"&&return 1
value_name_update_config="$1" value_update_config="$2" config_path_update_config="$3"
! [ -f "$config_path_update_config" ]&&: >|"$config_path_update_config"
chmod u+w "$config_path_update_config"||return 1
printf "%s\n%s\n" "$(grep -v -e "^$" -e "^$value_name_update_config=" "$config_path_update_config"||:)" \
"$value_name_update_config=\"$value_update_config\"" >|"$config_path_update_config"||return 1
chmod a-w-r-x,u+r "$config_path_update_config"||return 1
return 0
}
{
[ "${_SHELL:-}" = "bash" ]&&tmp="-f"&&export "${tmp?}" _actual_size_in_bytes \
_bytes_to_human \
_clear_line \
_curl \
_json_value \
_move_cursor \
_print_center \
_print_center_quiet \
_update_config
} 2>|/dev/null 1>&2||:
_api_request(){
_curl --compressed ${CURL_PROGRESS:-} \
-e "https://drive.google.com" \
"${API_URL:?}/drive/${API_VERSION:?}/${1:?}&key=${API_KEY:?}&supportsAllDrives=true&includeItemsFromAllDrives=true"||return 1
_clear_line 1 1>&2
}
_api_request_oauth(){
. "${TMPFILE:?}_ACCESS_TOKEN"
_curl --compressed ${CURL_PROGRESS:-} \
-H "Authorization: Bearer ${ACCESS_TOKEN:?}" \
"${API_URL:?}/drive/${API_VERSION:?}/${1:?}&supportsAllDrives=true&includeItemsFromAllDrives=true"||return 1
_clear_line 1 1>&2
}
_check_id(){
export EXTRA_LOG API_REQUEST_FUNCTION QUIET
[ $# = 0 ]&&printf "Missing arguments\n"&&return 1
"$EXTRA_LOG" "justify" "Validating URL/ID.." "-"
id_check_id="$1" json_check_id=""
if json_check_id="$("$API_REQUEST_FUNCTION" "files/$id_check_id?alt=json&fields=name,size,mimeType")";then
if ! printf "%s\n" "$json_check_id"|_json_value code 1 1 2>|/dev/null 1>&2;then
NAME="$(printf "%s\n" "$json_check_id"|_json_value name 1 1||:)"
mime_check_id="$(printf "%s\n" "$json_check_id"|_json_value mimeType 1 1||:)"
_clear_line 1
case "$mime_check_id" in
*folder*)\
FOLDER_ID="$id_check_id"
_print_center "justify" "Folder Detected" "="&&_newline "\n"
;;
*)\
SIZE="$(printf "%s\n" "$json_check_id"|_json_value size 1 1||:)"
FILE_ID="$id_check_id"
_print_center "justify" "File Detected" "="&&_newline "\n"
esac
export NAME SIZE FILE_ID FOLDER_ID
else
_clear_line 1&&"${QUIET:-_print_center}" "justify" "Invalid URL/ID" "="&&_newline "\n"
return 1
fi
else
_clear_line 1
"${QUIET:-_print_center}" "justify" "Error: Cannot check URL/ID" "="
printf "%s\n" "$json_check_id"
return 1
fi
return 0
}
_extract_id(){
[ $# = 0 ]&&printf "Missing arguments\n"&&return 1
id_extract_id="$1"
case "$id_extract_id" in
*'drive.google.com'*'id='*)_tmp="${id_extract_id##*id=}"&&_tmp="${_tmp%%\?*}"&&id_extract_id="${_tmp%%\&*}";;
*'drive.google.com'*'file/d/'*|'http'*'docs.google.com'*'/d/'*)_tmp="${id_extract_id##*\/d\/}"&&_tmp="${_tmp%%\/*}"&&_tmp="${_tmp%%\?*}"&&id_extract_id="${_tmp%%\&*}";;
*'drive.google.com'*'drive'*'folders'*)_tmp="${id_extract_id##*\/folders\/}"&&_tmp="${_tmp%%\?*}"&&id_extract_id="${_tmp%%\&*}";;
*):
esac
if [ -n "$2" ];then
_set_value d "$2" "$id_extract_id"
else
printf "%b" "${id_extract_id:+$id_extract_id\n}"
fi
}
{
[ "${_SHELL:-}" = "bash" ]&&tmp="-f"&&export "${tmp?}" _api_request \
_api_request_oauth \
_check_id \
_extract_id
} 2>|/dev/null 1>&2||:
_common_stuff(){
export OAUTH_ENABLED TMPFILE ACCESS_TOKEN API_URL API_VERSION API_KEY API_KEY_DOWNLOAD EXTRA_LOG CURL_PROGRESS DOWNLOADER
if [ -n "$OAUTH_ENABLED" ];then
. "${TMPFILE}_ACCESS_TOKEN"
flag_download_file="--header" flag_value_download_file="Authorization: Bearer $ACCESS_TOKEN"
url_download_file="$API_URL/drive/$API_VERSION/files/$file_id_download_file?alt=media&supportsAllDrives=true&includeItemsFromAllDrives=true"
elif [ -n "$API_KEY_DOWNLOAD" ];then
flag_download_file="--referer" flag_value_download_file="https://drive.google.com"
url_download_file="$API_URL/drive/$API_VERSION/files/$file_id_download_file?alt=media&supportsAllDrives=true&includeItemsFromAllDrives=true&key=$API_KEY"
else
"$EXTRA_LOG" "justify" "Fetching" " cookies.." "-"
_curl -I $CURL_PROGRESS \
-c "${TMPFILE}_${file_id_download_file}_COOKIE" -o /dev/null \
"https://drive.google.com/uc?export=download&id=$file_id_download_file"||:
for _ in 1 2;do _clear_line 1;done
confirm_string="$(_tmp="$(grep -F 'download_warning' "${TMPFILE}_${file_id_download_file}_COOKIE")"&&printf "%s\n" "${_tmp##*"$(printf '\t')"}")"||:
flag_download_file="-b" flag_value_download_file="${TMPFILE}_${file_id_download_file}_COOKIE"
[ "$DOWNLOADER" = "aria2c" ]&&{
cookies_download_file="$(sed -e "s/^\# .*//g" -e "s/^\#HttpOnly_//g" "${TMPFILE}_${file_id_download_file}_COOKIE")"
printf "%s\n" "$cookies_download_file" >|"${TMPFILE}_${file_id_download_file}_COOKIE"
flag_download_file="--load-cookies"
}
url_download_file="https://drive.google.com/uc?export=download&id=$file_id_download_file${confirm_string:+&confirm=$confirm_string}"
fi
return 0
}
_download_with_aria2c(){
export ARIA_FLAGS QUIET
[ $# -lt 3 ]&&printf "Missing arguments\n"&&return 1
file_id_download_file="$1" name_download_file="$2" server_size_download_file="$3" parallel_download_file="$4"
unset flag_download_file flag_value_download_file url_download_file cookies_download_file
server_size_readable_download_file="$(_bytes_to_human "$server_size_download_file")"
_print_center "justify" "$name_download_file" " | ${server_size_download_file:+$server_size_readable_download_file}" "="
_common_stuff
download_status=0
aria2c $ARIA_FLAGS \
"$flag_download_file" "$flag_value_download_file" \
"$url_download_file" -o "$name_download_file"||download_status=1
if [ "$download_status" -eq 0 ];then
"${QUIET:-_print_center}" "justify" "Downloaded" "="&&_newline "\n"
rm -f "$name.aria2"
else
"${QUIET:-_print_center}" "justify" "Error: Incomplete" " download." "=" 1>&2
return 1
fi
_log_in_file "$name_download_file" "$server_size_readable_download_file" "$file_id_download_file"
return 0
}
_download_with_curl(){
export QUIET
[ $# -lt 3 ]&&printf "Missing arguments\n"&&return 1
file_id_download_file="$1" name_download_file="$2" server_size_download_file="$3" parallel_download_file="$4"
unset range_download_file downloaded_download_file old_downloaded_download_file left_download_file speed_download_file eta_download_file \
flag_download_file flag_value_download_file url_download_file cookies_download_file
server_size_readable_download_file="$(_bytes_to_human "$server_size_download_file")"
_print_center "justify" "$name_download_file" " | ${server_size_download_file:+$server_size_readable_download_file}" "="
if [ -s "$name_download_file" ];then
local_size_download_file="$(_actual_size_in_bytes "$name_download_file")"
if [ "$local_size_download_file" -ge "$server_size_download_file" ];then
"${QUIET:-_print_center}" "justify" "File already present" "="&&_newline "\n"
_log_in_file
return 0
else
_print_center "justify" "File is partially" " present, resuming.." "-"
range_download_file="Range: bytes=$local_size_download_file-$server_size_download_file"
fi
else
[ "$server_size_download_file" -gt 0 ]&&range_download_file="Range: bytes=0-$server_size_download_file"
_print_center "justify" "Downloading file.." "-"
fi
_common_stuff
_curl -Ls \
--header "$range_download_file" \
"$flag_download_file" "$flag_value_download_file" \
"$url_download_file" >>"$name_download_file"&
pid="$!"
if [ -n "$parallel_download_file" ];then
wait "$pid" 2>|/dev/null 1>&2
else
until [ -f "$name_download_file" ]||! kill -0 "$pid" 2>|/dev/null 1>&2;do sleep 0.5;done
_newline "\n\n"
until ! kill -0 "$pid" 2>|/dev/null 1>&2;do
downloaded_download_file="$(_actual_size_in_bytes "$name_download_file")"
left_download_file="$((server_size_download_file-downloaded_download_file))"
speed_download_file="$((downloaded_download_file-old_downloaded_download_file))"
{ [ "$speed_download_file" -gt 0 ]&&eta_download_file="$(_display_time "$((left_download_file/speed_download_file))")";}||eta_download_file=""
sleep 0.5
_move_cursor 2
_print_center "justify" "Downloaded: $(_bytes_to_human "$downloaded_download_file") " "| Left: $(_bytes_to_human "$left_download_file")" "="
_print_center "justify" "Speed: $(_bytes_to_human "$speed_download_file")/s " "| ETA: ${eta_download_file:-Unknown}" "-"
old_downloaded_download_file="$downloaded_download_file"
done
fi
if [ "$(_actual_size_in_bytes "$name_download_file")" -ge "$server_size_download_file" ];then
for _ in 1 2 3;do _clear_line 1;done
"${QUIET:-_print_center}" "justify" "Downloaded" "="&&_newline "\n"
rm -f "$name.aria2"
else
"${QUIET:-_print_center}" "justify" "Error: Incomplete" " download." "=" 1>&2
return 1
fi
_log_in_file "$name_download_file" "$server_size_readable_download_file" "$file_id_download_file"
return 0
}
_download_file_main(){
export DOWNLOADER
[ $# -lt 2 ]&&printf "Missing arguments\n"&&return 1
unset line_download_file_main fileid_download_file_main name_download_file_main size_download_file_main parallel_download_file_main RETURN_STATUS sleep_download_file_main&&retry_download_file_main="${RETRY:-0}"
if [ "$1" = parse ];then
parallel_download_file_main="$3"
line_download_file_main="$2"
fileid_download_file_main="${line_download_file_main%%"|:_//_:|"*}"
name_download_file_main="${line_download_file_main##*"|:_//_:|"}"
size_download_file_main="$(_tmp="${line_download_file_main#*"|:_//_:|"}"&&printf "%s\n" "${_tmp%"|:_//_:|"*}")"
else
fileid_download_file_main="$2"
name_download_file_main="$3"
size_download_file_main="$4"
parallel_download_file_main="$5"
fi
[ -z "${fileid_download_file_main:+$name_download_file_main}" ]&&return 0
unset RETURN_STATUS&&until [ "$retry_download_file_main" -le 0 ]&&[ -n "$RETURN_STATUS" ];do
if [ -n "$parallel_download_file_main" ];then
"_download_with_$DOWNLOADER" "$fileid_download_file_main" "$name_download_file_main" "$size_download_file_main" true 2>|/dev/null 1>&2&&RETURN_STATUS=1&&break
else
"_download_with_$DOWNLOADER" "$fileid_download_file_main" "$name_download_file_main" "$size_download_file_main"&&RETURN_STATUS=1&&break
fi
sleep "$((sleep_download_file_main+=1))"
RETURN_STATUS=2 retry_download_file_main="$((retry_download_file_main-1))"&&continue
done
{ [ "$RETURN_STATUS" = 1 ]&&printf "%b" "${parallel_download_file_main:+$RETURN_STATUS\n}";}||printf "%b" "${parallel_download_file_main:+$RETURN_STATUS\n}" 1>&2
return 0
}
_download_folder(){
export EXTRA_LOG QUIET API_REQUEST_FUNCTION INCLUDE_FILES EXCLUDE_FILES TMPFILE VERBOSE SKIP_SUBDIRS NO_OF_PARALLEL_JOBS
[ $# = 0 ]&&printf "Missing arguments\n"&&return 1
folder_id_download_folder="$1" name_download_folder="$2" parallel_download_folder="$3"
unset json_search_download_folder json_search_fragment_download_folder next_page_token \
error_status_download_folder success_status_download_folder \
files_download_folder folders_download_folder files_size_download_folder files_name_download_folder folders_name_download_folder \
num_of_files_download_folder num_of_folders_download_folder
_newline "\n"
"$EXTRA_LOG" "justify" "$name_download_folder" "="
"$EXTRA_LOG" "justify" "Fetching folder" " details.." "-"
_search_error_message_download_folder(){
"${QUIET:-_print_center}" "justify" "Error: Cannot" ", fetch folder details." "="
printf "%s\n" "${1:?}"&&return 1
}
if json_search_download_folder="$("$API_REQUEST_FUNCTION" "files?q=%27$folder_id_download_folder%27+in+parents&fields=nextPageToken,files(name,size,id,mimeType)&pageSize=1000&orderBy=name")";then
until ! next_page_token="$(printf "%s\n" "${json_search_fragment_download_folder:-$json_search_download_folder}"|_json_value nextPageToken 1 1)";do
json_search_fragment_download_folder="$("$API_REQUEST_FUNCTION" "files?q=%27$folder_id_download_folder%27+in+parents&fields=nextPageToken,files(name,size,id,mimeType)&pageSize=1000&orderBy=name&pageToken=$next_page_token")"||_search_error_message_download_folder "$json_search_fragment_download_folder"
json_search_download_folder="$json_search_download_folder
$json_search_fragment_download_folder"
done
else
_search_error_message_download_folder "$json_search_download_folder"
fi&&_clear_line 1
"$EXTRA_LOG" "justify" "Preparing files list.." "="
files_download_folder="$(printf "%s\n" "$json_search_download_folder"|grep '"size":' -B3|_json_value id all all)"||:
files_size_download_folder="$(printf "%s\n" "$json_search_download_folder"|_json_value size all all)"||:
files_name_download_folder="$(printf "%s\n" "$json_search_download_folder"|grep size -B2|_json_value name all all)"||:
exec 5<<EOF
$(printf "%s\n" "$files_download_folder")
EOF
exec 6<<EOF
$(printf "%s\n" "$files_size_download_folder")
EOF
exec 7<<EOF
$(printf "%s\n" "$files_name_download_folder")
EOF
files_list_download_folder="$(while read -r id <&5&&read -r size <&6&&read -r name <&7;do
[ -n "${id:+$name}" ]&&printf "%s\n" "$id|:_//_:|$size|:_//_:|$name"
done)"
exec 5<&-&&exec 6<&-&&exec 7<&-
_clear_line 1
[ -n "$INCLUDE_FILES" ]&&files_list_download_folder="$(printf "%s\n" "$files_list_download_folder"|grep -E "$INCLUDE_FILES")"
[ -n "$EXCLUDE_FILES" ]&&files_list_download_folder="$(printf "%s\n" "$files_list_download_folder"|grep -Ev "$EXCLUDE_FILES")"
"$EXTRA_LOG" "justify" "Preparing sub folders list.." "="
folders_download_folder="$(printf "%s\n" "$json_search_download_folder"|grep '"mimeType":.*folder.*' -B2|_json_value id all all)"||:
folders_name_download_folder="$(printf "%s\n" "$json_search_download_folder"|grep '"mimeType":.*folder.*' -B1|_json_value name all all)"||:
exec 5<<EOF
$(printf "%s\n" "$folders_download_folder")
EOF
exec 6<<EOF
$(printf "%s\n" "$folders_name_download_folder")
EOF
folders_list_download_folder="$(while read -r id <&5&&read -r name <&6;do
[ -n "${id:+$name}" ]&&printf "%s\n" "$id|:_//_:|$name"
done)"
exec 5<&-&&exec 6<&-
_clear_line 1
if [ -z "${files_list_download_folder:-$folders_download_folder}" ];then
for _ in 1 2;do _clear_line 1;done&&_print_center "justify" "$name_download_folder" " | Empty Folder" "="&&_newline "\n"&&return 0
fi
[ -n "$files_list_download_folder" ]&&num_of_files_download_folder="$(($(printf "%s\n" "$files_list_download_folder"|_count)))"
[ -n "$folders_download_folder" ]&&num_of_folders_download_folder="$(($(printf "%s\n" "$folders_download_folder"|_count)))"
for _ in 1 2;do _clear_line 1;done
_print_center "justify" \
"$name_download_folder" \
"${num_of_files_download_folder:+ | $num_of_files_download_folder files}${num_of_folders_download_folder:+ | $num_of_folders_download_folder sub folders}" "="&&_newline "\n\n"
if [ -f "$name_download_folder" ];then
name_download_folder="$name_download_folder$(_epoch)"
fi&&mkdir -p "$name_download_folder"
cd "$name_download_folder"||exit 1
if [ -n "$num_of_files_download_folder" ];then
if [ -n "$parallel_download_folder" ];then
NO_OF_PARALLEL_JOBS_FINAL="$((NO_OF_PARALLEL_JOBS>num_of_files_download_folder?num_of_files_download_folder:NO_OF_PARALLEL_JOBS))"
[ -f "$TMPFILE"SUCCESS ]&&rm "$TMPFILE"SUCCESS
[ -f "$TMPFILE"ERROR ]&&rm "$TMPFILE"ERROR
(printf "%s\n" "$files_list_download_folder"|xargs -P"$NO_OF_PARALLEL_JOBS_FINAL" -I "{}" -n 1 "${_SHELL:-sh}" -c '
                eval "${SOURCE_UTILS}"
                _download_file_main parse "{}" true
             ' 1>|"$TMPFILE"SUCCESS 2>|"$TMPFILE"ERROR)&
pid="$!"
until [ -f "$TMPFILE"SUCCESS ]||[ -f "$TMPFILE"ERROR ];do sleep 0.5;done
_clear_line 1
until ! kill -0 "$pid" 2>|/dev/null 1>&2;do
success_status_download_folder="$(($(_count <"$TMPFILE"SUCCESS)))"
error_status_download_folder="$(($(_count <"$TMPFILE"ERROR)))"
sleep 1
if [ "$((success_status_download_folder+error_status_download_folder))" != "$TOTAL" ];then
printf '%s\r' "$(_print_center "justify" "Status" ": ${success_status_download_folder:-0} Downloaded | ${error_status_download_folder:-0} Failed" "=")"
fi
TOTAL="$((success_status_download_folder+error_status_download_folder))"
done
_newline "\n"
success_status_download_folder="$(($(_count <"$TMPFILE"SUCCESS)))"
error_status_download_folder="$(($(_count <"$TMPFILE"ERROR)))"
_clear_line 1&&_newline "\n"
else
while read -r line <&4&&{ [ -n "$line" ]||continue;};do
_download_file_main parse "$line"
: "$((RETURN_STATUS<2?(success_status_download_folder+=1):(error_status_download_folder+=1)))"
if [ -z "$VERBOSE" ];then
for _ in 1 2 3 4;do _clear_line 1;done
fi
_print_center "justify" "Status" ": ${success_status_download_folder:-0} Downloaded | ${error_status_download_folder:-0} Failed" "="
done 4<<EOF
$(printf "%s\n" "$files_list_download_folder")
EOF
fi
fi
for _ in 1 2;do _clear_line 1;done
[ "$success_status_download_folder" -gt 0 ]&&"${QUIET:-_print_center}" "justify" "Downloaded" ": $success_status_download_folder" "="
[ "${error_status_download_folder:-0}" -gt 0 ]&&"${QUIET:-_print_center}" "justify" "Failed" ": $error_status_download_folder" "="
_newline "\n"
if [ -z "$SKIP_SUBDIRS" ]&&[ -n "$num_of_folders_download_folder" ];then
while read -r line <&4&&{ [ -n "$line" ]||continue;};do
(_download_folder "${line%%"|:_//_:|"*}" "${line##*"|:_//_:|"}" "${parallel:-}")
done 4<<EOF
$(printf "%s\n" "$folders_list_download_folder")
EOF
fi
cd - 2>|/dev/null 1>&2||exit 1
return 0
}
_log_in_file(){
export LOG_FILE_ID
[ -z "$LOG_FILE_ID" ]||[ -d "$LOG_FILE_ID" ]&&return 0
{
printf "%s\n" "Name: $1"
printf "%s\n" "Size: $2"
printf "%s\n\n" "ID: $3"
} >>"$LOG_FILE_ID"
}
{
[ "${_SHELL:-}" = "bash" ]&&tmp="-f"&&export "${tmp?}" _common_stuff \
_download_with_aria2c \
_download_with_curl \
_download_file_main \
_download_folder \
_log_in_file
} 2>|/dev/null 1>&2||:
_create_help(){
_set_help "-aria --aria-flags" \
'flags' \
"use aria2c to download. '-aria' does not take arguments." \
"To give custom flags as argument, use long flag, --aria-flags. e.g: --aria-flags '-s 10 -x 10'

Note 1: aria2c can only resume google drive downloads if '-k/--key' or '-o/--oauth' option is used.

Note 2: aria split downloading won't work in normal mode ( without '-k' or '-o' flag ) because it cannot get the remote server size. Same for any other feature which uses remote server size.

Note 3: By above notes, conclusion is, aria is basically same as curl in normal mode, so it is recommended to be used only with '--key' and '--oauth' flag."
_set_help "-o --oauth" \
"" \
"Use this flag to trigger oauth authentication." \
"Note: If both --oauth and --key flag is used, --oauth flag is preferred."
_set_help "-a --account" \
"account name" \
"Use different account than the default one." \
"To change the default account name, use this format, -a/--account default=account_name"
_set_help "-la --list-accounts" \
"" \
"Print all configured accounts in the config files."
_set_help "-ca --create-account" \
"account name" \
"To create a new account with the given name if does not already exists."
_set_help "-da --delete-account" \
"account name" \
"To delete an account information from config file."
_set_help "-k --key" \
"API KEY( optional )" \
"To download with api key. If api key is not specified, then the predefined api key will be used." \
"To save your api key in config file, use 'gdl --key default=your api key'.

     API key will be saved in '/data/data/com.termux/files/home/.gdl.conf' and will be used from now on.

     Note: If both --key and --key oauth is used, --oauth flag is preferred."
_set_help "-c --config" \
"config file path" \
"Override default config file with custom config file. Default: /data/data/com.termux/files/home/.gdl.conf"
_set_help "-d --directory" \
"foldername" \
"To download given input in custom directory."
_set_help "-s --skip-subdirs" \
"" \
"Skip downloading of sub folders present in case of folders."
_set_help "-p --parallel" \
"no of files to parallely download" \
"Download multiple files in parallel."
_set_help "--proxy" \
"http://user:password@host:port" \
"Specify a proxy to use, should be in the format accepted by curl --proxy and aria2c --all-proxy flag."
_set_help "--speed" \
"speed" \
"Limit the download speed, supported formats: 1K and 1M."
_set_help "-ua --user-agent" \
"user agent string" \
"Specify custom user agent."
_set_help "-R --retry" \
"num of retries" \
"Retry the file upload if it fails, postive integer as argument. Currently only for file uploads."
_set_help "-in --include" \
"pattern" \
"Only download the files which contain the given pattern - Applicable for folder downloads." \
"e.g: gdl local_folder --include '1', will only include with files with pattern '1' in the name. Regex can be used which works with grep -E command."
_set_help "-ex --exclude" \
"pattern" \
"Only download the files which does not contain the given pattern - Applicable for folder downloads." \
"e.g: gdl local_folder --exclude '1', will only include with files with pattern '1' not present in the name. Regex can be used which works with grep -E command."
_set_help "-l --log" \
"file to save info" \
"Save downloaded files info to the given filename."
_set_help "-q --quiet" \
"" \
"Supress the normal output, only show success/error upload messages for files, and one extra line at the beginning for folder showing no. of files and sub folders."
_set_help "--verbose" \
"" \
"Display detailed message (only for non-parallel uploads)"
_set_help "--skip-internet-check" \
"" \
"Do not check for internet connection, recommended to use in sync jobs."
_set_help "-V --version --info" \
"" \
"Show detailed info, only if script is installed system wide."
_set_help "-D --debug" \
"" \
"Display script command trace."
_set_help "-h --help" \
"flag name (optional)" \
"Print help for all flags and basic usage instructions." \
"To see help for a specific flag, --help flag_name ( with or without dashes )
e.g: ${0##*/} --help aria"
[ "${GDL_INSTALLED_WITH:-}" = script ]&&{
_set_help "-u --update" \
"" \
"Update the installed script in your system."
_set_help "--uninstall" \
"" \
"Uninstall script, remove related files."
}
ALL_HELP="
The script can be used to download file/directory from google drive.

Usage: ${0##*/} [options.. ] <file_[url|id]> or <folder[url|id]>

Options:$ALL_HELP"
}
_short_help(){
printf "No valid arguments provided, use -h/--help flag to see usage.\n"
exit 0
}
_usage(){
DEBUG="" _check_debug
_HELP_BAR="$(_print_center "normal" "_" "_")"
[ -n "$_HELP_BAR" ]&&export _HELP_BAR="$_HELP_BAR
"
_set_help(){
content1_set_help="$3" content2_set_help="" all_content_set_help=""
[ -n "$4" ]&&{
content2_set_help="
"
while read -r line <&4;do
content2_set_help="$content2_set_help
        $line"
done 4<<EOF
$4
EOF
}
start_set_help=""
for f in $1;do
start_set_help="${start_set_help:+$start_set_help | }$f"
done
start_set_help="    $start_set_help ${2:+\"$2\"} => "
all_content_set_help="$start_set_help$content1_set_help$content2_set_help"
_flag_help set "$1" "$all_content_set_help"
ALL_HELP="$ALL_HELP
$_HELP_BAR
$all_content_set_help"
}
_create_help
[ -n "$1" ]&&{
tmp_help_usage=""
_flag_help get tmp_help_usage "$1"
if [ -z "$tmp_help_usage" ];then
printf "%s\n" "Error: No help found for $1"
else
printf "%s\n%s\n%s\n" "$_HELP_BAR" "$tmp_help_usage" "$_HELP_BAR"
fi
exit 0
}
printf "%s\n" "$ALL_HELP"
exit 0
}
_cleanup_config(){
config="${1:?Error: Missing config}"&&unset values_regex _tmp
! [ -f "$config" ]&&return 0
while read -r line <&4&&[ -n "$line" ];do
expiry_value_name="${line%%=*}"
token_value_name="${expiry_value_name%%_EXPIRY}"
_tmp="${line##*=}"&&_tmp="${_tmp%\"}"&&expiry="${_tmp#\"}"
[ "$expiry" -le "$(_epoch)" ]&&values_regex="${values_regex:+$values_regex|}$expiry_value_name=\".*\"|$token_value_name=\".*\""
done 4<<EOF
$(grep -F ACCESS_TOKEN_EXPIRY "$config"||:)
EOF
chmod u+w "$config"&&printf "%s\n" "$(grep -Ev "^\$${values_regex:+|$values_regex}" "$config")" >|"$config"&&chmod "a-w-r-x,u+r" "$config"
return 0
}
_version_info(){
export COMMAND_NAME REPO INSTALL_PATH TYPE TYPE_VALUE
if command -v "$COMMAND_NAME" 1>/dev/null&&[ -n "${REPO:+${COMMAND_NAME:+${INSTALL_PATH:+${TYPE:+$TYPE_VALUE}}}}" ];then
for i in REPO INSTALL_PATH INSTALLATION TYPE TYPE_VALUE LATEST_INSTALLED_SHA CONFIG;do
value_version_info=""
_set_value i value_version_info "$i"
printf "%s\n" "$i=$value_version_info"
done|sed -e "s/=/: /g"
else
printf "%s\n" "gdrive-downloader is not installed system wide."
fi
exit 0
}
_setup_arguments(){
[ $# = 0 ]&&printf "Missing arguments\n"&&return 1
unset LIST_ACCOUNTS UPDATE_DEFAULT_ACCOUNT CUSTOM_ACCOUNT_NAME NEW_ACCOUNT_NAME DELETE_ACCOUNT_NAME ACCOUNT_ONLY_RUN ACCOUNT_NAME
unset LOG_FILE_ID OAUTH_ENABLED API_KEY_DOWNLOAD FOLDERNAME SKIP_SUBDIRS NO_OF_PARALLEL_JOBS PARALLEL_DOWNLOAD ALL_HELP
unset DEBUG QUIET VERBOSE SKIP_INTERNET_CHECK RETRY SPEED_LIMIT USER_AGENT PROXY
unset TOTAL_INPUTS ID_INPUT INCLUDE_FILES EXCLUDE_FILES
unset ARIA_FLAGS CURL_FLAGS
export DOWNLOADER="curl"
export USER_AGENT_FLAG="--user-agent"
export ARIA_SPEED_LIMIT_FLAG="--max-download-limit" \
CURL_SPEED_LIMIT_FLAG="--limit-rate" \
ARIA_PROXY_FLAG="--all-proxy" \
CURL_PROXY_FLAG="--proxy"
export CURL_PROGRESS="-s" EXTRA_LOG=":"
CONFIG="$HOME/.gdl.conf"
unset ROOT_FOLDER ROOT_FOLDER_NAME CLIENT_ID CLIENT_SECRET REFRESH_TOKEN ACCESS_TOKEN ACCESS_TOKEN_EXPIRY INITIAL_ACCESS_TOKEN
export API_KEY="AIzaSyD2dHsZJ9b4OXuy5B_owiL8W18NaNOM8tk" \
API_URL="https://www.googleapis.com"
export API_VERSION="v3" \
SCOPE="$API_URL/auth/drive" \
REDIRECT_URI="urn:ietf:wg:oauth:2.0:oob" \
TOKEN_URL="https://accounts.google.com/o/oauth2/token"
_check_longoptions(){
[ -z "$2" ]&&{
printf "%s\n" "${0##*/}: $1: flag requires an argument."
printf "\n%s\n" "Help:"
printf "%s\n" "    $(_usage "$1")"
exit 1
}
return 0
}
while [ "$#" -gt 0 ];do
case "$1" in
-h|--help)_usage "$2";;
-D|--debug)DEBUG="true"&&export DEBUG;;
-V|--version|--info)_version_info;;
-l|--log)_check_longoptions "$1" "$2"
export LOG_FILE_ID="$2"&&shift
;;
-aria|--aria-flags)command -v aria2c \
1>|/dev/null||{
printf "%s\n" "Error: aria2c not installed."&&exit 1
}
DOWNLOADER="aria2c"
[ "$1" = "--aria-flags" ]&&{
_check_longoptions "$1" "$2"
ARIA_FLAGS=" $ARIA_FLAGS $2 "&&shift
}
;;
-o|--oauth)export OAUTH_ENABLED="true";;
-a|--account)export \
OAUTH_ENABLED="true"
_check_longoptions "$1" "$2"
export CUSTOM_ACCOUNT_NAME="${2##default=}"&&shift
[ -z "${2##default=*}" ]&&export UPDATE_DEFAULT_ACCOUNT="_update_config"
;;
-la|--list-account)export LIST_ACCOUNTS="true";;
-ca|--create-account)export \
OAUTH_ENABLED="true"
_check_longoptions "$1" "$2"
export NEW_ACCOUNT_NAME="$2"&&shift
;;
-da|--delete-account)_check_longoptions "$1" "$2"
export DELETE_ACCOUNT_NAME="$2"&&shift
;;
-k|--key)export \
API_KEY_DOWNLOAD="true"
_API_KEY="${2##default=}"
regex="AIza[0-9A-Za-z_-]{35}"
if [ -n "$_API_KEY" ]&&_assert_regex "$regex" "$_API_KEY";then
export API_KEY="$_API_KEY"&&shift
[ -z "${2##default=*}" ]&&UPDATE_DEFAULT_API_KEY="_update_config"
fi
;;
-c|--config)_check_longoptions "$1" "$2"
CONFIG="$2"&&shift
;;
-d|--directory)_check_longoptions "$1" "$2"
export FOLDERNAME="$2"&&shift
;;
-s|--skip-subdirs)export \
SKIP_SUBDIRS="true"
;;
-p|--parallel)_check_longoptions "$1" "$2"
if [ "$2" -gt 0 ] 2>|/dev/null 1>&2;then
export NO_OF_PARALLEL_JOBS="$2"
else
printf "\nError: -p/--parallel accepts values between 1 to 10.\n"
exit 1
fi
export PARALLEL_DOWNLOAD="parallel"&&shift
;;
--proxy)_check_longoptions "$1" "$2"
export PROXY="$2"&&shift
;;
--speed)_check_longoptions "$1" "$2"
regex='^([0-9]+)([k,K]|[m,M])+$'
if _assert_regex "$regex" "$2";then
export SPEED_LIMIT="$2"&&shift
else
printf "Error: Wrong speed limit format, supported formats: 1K and 1M.\n" 1>&2
exit 1
fi
;;
-ua|--user-agent)_check_longoptions "$1" "$2"
export USER_AGENT="$2"&&shift
;;
-R|--retry)_check_longoptions "$1" "$2"
if [ "$((2))" -gt 0 ] 2>|/dev/null 1>&2;then
export RETRY="$2"&&shift
else
printf "Error: -R/--retry only takes positive integers as arguments, min = 1, max = infinity.\n"
exit 1
fi
;;
-in|--include)_check_longoptions "$1" "$2"
export INCLUDE_FILES="${INCLUDE_FILES:+$INCLUDE_FILES|}$2"&&shift
;;
-ex|--exclude)_check_longoptions "$1" "$2"
export EXCLUDE_FILES="${EXCLUDE_FILES:+$EXCLUDE_FILES|}$2"&&shift
;;
-q|--quiet)export QUIET="_print_center_quiet";;
--verbose)export VERBOSE="true" CURL_PROGRESS="";;
--skip-internet-check)\
SKIP_INTERNET_CHECK=":"
;;
''):;;
-*)[ "${GDL_INSTALLED_WITH:-}" = script ]&&{
case "$1" in
-u|--update)_check_debug&&_update&&{
exit 0||exit 1
}
;;
--uninstall)_check_debug&&_update uninstall&&{
exit 0||exit 1
}
;;
*):
esac
}
printf '%s: %s: Unknown option\nTry '"%s -h/--help"' for more information.\n' "${0##*/}" "$1" "${0##*/}"&&exit 1
;;
*)\
_tmp_id=""&&_extract_id "$1" _tmp_id
[ -n "$_tmp_id" ]&&_set_value d "INPUT_ID_$((TOTAL_INPUTS+=1))" "$_tmp_id"
esac
shift
done
_check_debug
[ -n "$QUIET" ]&&export CURL_PROGRESS="-s" ARIA_FLAGS=" $ARIA_FLAGS -q "
ARIA_extra_flags="" CURL_extra_flags=""
for downloader in CURL ARIA;do
extra_flags="" flag="" value=""
for var in SPEED_LIMIT USER_AGENT PROXY;do
_set_value i value "$var"
[ -n "$value" ]&&{
_set_value i flag "${downloader}_${var}_FLAG"
extra_flags="$extra_flags $flag $value"
}
done
_set_value d "${downloader}_extra_flags" "$extra_flags"
done
export ARIA_FLAGS="$ARIA_FLAGS --auto-file-renaming=false --continue $ARIA_extra_flags"
export CURL_FLAGS="$CURL_FLAGS $CURL_extra_flags"
[ -n "$OAUTH_ENABLED" ]&&unset API_KEY_DOWNLOAD
[ -n "$API_KEY_DOWNLOAD" ]&&"${UPDATE_DEFAULT_API_KEY:-:}" API_KEY "$API_KEY" "$CONFIG"
[ -n "$DELETE_ACCOUNT_NAME" ]&&_delete_account "$DELETE_ACCOUNT_NAME"
[ -n "$LIST_ACCOUNTS" ]&&_all_accounts
[ -z "$INPUT_ID_1" ]&&{
[ -z "${DELETE_ACCOUNT_NAME:-${LIST_ACCOUNTS:-$NEW_ACCOUNT_NAME}}" ]&&_short_help
[ -n "${DELETE_ACCOUNT_NAME:-${LIST_ACCOUNTS:-}}" ]&&exit 0
[ -n "$NEW_ACCOUNT_NAME" ]&&CONTINUE_WITH_NO_INPUT="true"
}
return 0
}
_setup_traps(){
_cleanup(){
[ -n "$SUPPORT_ANSI_ESCAPES" ]&&printf "\033[?25h\033[?7h"
{
[ -f "${TMPFILE}_ACCESS_TOKEN" ]&&{
. "${TMPFILE}_ACCESS_TOKEN"
export ACCESS_TOKEN ACCESS_TOKEN_EXPIRY INITIAL_ACCESS_TOKEN ACCOUNT_NAME
[ "$INITIAL_ACCESS_TOKEN" = "$ACCESS_TOKEN" ]||{
_update_config "ACCOUNT_${ACCOUNT_NAME}_ACCESS_TOKEN" "$ACCESS_TOKEN" "$CONFIG"
_update_config "ACCOUNT_${ACCOUNT_NAME}_ACCESS_TOKEN_EXPIRY" "$ACCESS_TOKEN_EXPIRY" "$CONFIG"
}
}||: 1>|/dev/null
[ -n "$ACCESS_TOKEN_SERVICE_PID" ]&&{
token_service_pids="$(ps --ppid="$ACCESS_TOKEN_SERVICE_PID" -o pid=)"
kill "$ACCESS_TOKEN_SERVICE_PID"
}||: 1>|/dev/null
script_children_pids="$(ps --ppid="$MAIN_PID" -o pid=)"
kill $token_service_pids $script_children_pids 1>|/dev/null
rm -f "${TMPFILE:?}"*
export abnormal_exit&&if [ -n "$abnormal_exit" ];then
printf "\n\n%s\n" "Script exited manually."
kill "${_SCRIPT_KILL_SIGNAL:--9}" -$$&
else
{ _cleanup_config "$CONFIG"&&[ "$GDL_INSTALLED_WITH" = script ]&&_auto_update;} 1>|/dev/null&
fi
} 2>|/dev/null||:
return 0
}
trap 'abnormal_exit="1" ; exit' INT TERM
trap '_cleanup' EXIT
trap '' TSTP
export MAIN_PID="$$"
}
_process_arguments(){
export FOLDERNAME TOTAL_INPUTS FILE_ID="" FOLDER_ID="" NAME="" PARALLEL_DOWNLOAD SIZE=""
${FOLDERNAME:+mkdir -p $FOLDERNAME}
cd "${FOLDERNAME:-.}" 2>|/dev/null 1>&2||exit 1
_SEEN="" index_process_arguments=0
TOTAL_INPUTS="$((TOTAL_INPUTS<0?0:TOTAL_INPUTS))"
until [ "$index_process_arguments" -eq "$TOTAL_INPUTS" ];do
_set_value i FILE_ID "INPUT_ID_$((index_process_arguments+=1))"
case "$_SEEN" in
*"$FILE_ID"*)continue;;
*)_SEEN="$_SEEN$FILE_ID"
esac
_check_id "$FILE_ID"||continue
if [ -n "$FOLDER_ID" ];then
_download_folder "$FOLDER_ID" "$NAME" "${PARALLEL_DOWNLOAD:-}"
else
_download_file_main noparse "$FILE_ID" "$NAME" "$SIZE"
fi
done
return 0
}
_main_helper(){
_setup_arguments "$@"||exit 1
"${SKIP_INTERNET_CHECK:-_check_internet}"||exit 1
TMPFILE="$(command -v mktemp 1>|/dev/null&&mktemp -u)"||TMPFILE="$(pwd)/.$(_t="$(_epoch)"&&printf "%s\n" "$((_t*_t))").tmpfile"
export TMPFILE
_setup_traps
if [ -n "$OAUTH_ENABLED" ];then
"$EXTRA_LOG" "justify" "Checking credentials.." "-"
{ _check_credentials&&for _ in 1 2;do _clear_line 1;done;}||{ "${QUIET:-_print_center}" "normal" "[ Error: Credentials checking failed ]" "="&&exit 1;}
"${QUIET:-_print_center}" "normal" " Account: $ACCOUNT_NAME " "="
export API_REQUEST_FUNCTION="_api_request_oauth" OAUTH_ENABLED="true"
else
export API_REQUEST_FUNCTION="_api_request"
fi
[ -n "$CONTINUE_WITH_NO_INPUT" ]&&exit 0
START="$(_epoch)"
[ -n "$SUPPORT_ANSI_ESCAPES" ]&&printf "\033[?25l"
_process_arguments
END="$(_epoch)"
DIFF="$((END-START))"
"${QUIET:-_print_center}" "normal" " Time Elapsed: ""$((DIFF/60))"" minute(s) and ""$((DIFF%60))"" seconds. " "="
}
main(){
[[ $# == 0 ]]&&{
printf "No valid arguments provided, use -h/--help flag to see usage.\n"
exit 0
}
export _SHELL="bash"
[[ -z $SELF_SOURCE ]]&&{
export UTILS_FOLDER="${UTILS_FOLDER:-$PWD}"
export COMMON_PATH="${COMMON_UTILS_FILE:-$PWD}/../common"
{ . "$UTILS_FOLDER/common-utils.bash"&&. "$COMMON_PATH/help.sh"&&. "$COMMON_PATH/auth-utils.sh"&&. "$COMMON_PATH/common-utils.sh"&&. "$COMMON_PATH/drive-utils.sh"&&. "$COMMON_PATH/download-utils.sh"&&. "$COMMON_PATH/gdl-common.sh";}||{ printf "Error: Unable to source util files.\n"&&exit 1;}
}
export SOURCE_UTILS=""
[[ ${BASH_VERSINFO:-0} -ge 4 ]]||{ printf "Bash version lower than 4.x not supported.\n"&&return 1;}
set -o errexit -o noclobber -o pipefail||exit 1
export _SCRIPT_KILL_SIGNAL="--"
_main_helper "$@"||exit 1
}
{ [[ -z $SOURCED_GDL ]]&&main "$@";}||:
